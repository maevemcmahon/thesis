---
title: "Operanter"
output: html_document
---
```{r echo=FALSE, results="hide", message=FALSE}
library(ggplot2)
library(dplyr)
library(knitr)
```

#Operanter: open source hardware and software for avian operant conditioning
\chaptermark{Operanter}

The experiments in Chapter 2 suggest there may be subtle differences in the pattern of correlated neural activities in the auditory forebrain elicited by a song stimulus, depending on whether the stimulus has been Go or No-Go conditioned. These observations motivated further study of how the Go and No-Go stimuli are learned (as described in this thesis), as well as a related project to look more deeply for transcriptional signatures that may distinguish Go and NoGo activity patterns in the auditory forebrain [@George2018]. Both of these aims require ready access to operant conditioning apparatus and populations of healthy adult zebra finches. As the operant conditioning experiments in Chapter 2 were conducted in a laboratory in the Netherlands, my next aim therefore was to develop an operant conditioning apparatus for the Clayton lab in London where I was based. In consultation with Prof. Clayton and colleague Dr. Robert Lachlan, we decided to build, from scratch, an operant conditioning hardware/software system that could be readily modified for different experimental designs and purposes, and might also be of wider utility to other laboratories. In this Chapter I describe the result: development of Operanter, a new open source hardware and software system. Then in the following chapter (Chapter 4), I describe my validation of the system, and in Chapters 5 and 6 I describe experiments using the system for close characterisation of Go/No-Go learning in the zebra finch.

##The need for improved operant conditioning apparatus
In order to investigate psychological and neural processes, many researchers use operant conditioning. This form of learning occurs when a behaviour is modified by a consequence, which can be either a reinforcement or punishment [@Staddon2003]. Operant conditioning is frequently used to investigate learning processes; this research usually involves rats or mice [e.g. @Saar1998; @Sclafani2016]. Moreover, by training animals using operant conditioning, researchers can investigate perceptual and cognitive abilities [e.g. @Kwak2016; @MilettoPetrazzini2015; @Toal2016]. In linguistics and perceptual psychology, this type of research has frequently used songbirds, whose vocal learning shares similarities with human language development [e.g. @Holveck2007; @Spierings2014]. Operant conditioning is also used to study reward, addiction and drug mechanisms, mostly in rodents [e.g. @Sclafani2016; @GroeberTravis2015], but also in zebrafish and crustaceans [e.g. @Bhimani2016; @Parker2012].

Despite the commonness and utility of operant conditioning, most setups are expensive and require proprietary software and hardware. Few companies publish costs online (e.g Lafayette Neuroscience, Bioseb, Med Associates Inc, Harvard Apparatus), but the average cost of a single operant conditioning chamber has been estimated to be over USD 6000 [@Pineno2014]. Further, while these companies offer many modular features, they are designed only for rats and mice. Some universities have chambers designed specifically for their needs by an intra-university department, (e.g. Leiden University), but costs tend to remain high and altering boxes at a later date can prove expensive.

Open source solutions are currently underdeveloped or require expensive components. In avian operant conditioning, Sound Analysis Pro is often used [@Tchernichovski2000]. However, it requires a National Instruments I/O card (£156) and only runs on the Windows operating system. Sound Analysis Pro is also difficult to customise for training regimens such as Go/No-Go or ABX. A new piece of free software from the Tchernichovsky lab, BirdPuffer, uses social interaction as reinforcement and a puff of air as a punishment [@Tokarev2014]. However, there are some instances for which this setup might not be ideal, such as when testing female preference for male song. Other open source solutions include ArduiPod Box, which is limited to rats interacting with a touchscreen on an iPod touch [@Pineno2014]. Despite incorporating an Arduino computer, the ArduiPod Box software primarily runs on the iPod touch. Despite the author hoping the ArduiPod Box will be extended by users, there is currently no mechanism for doing so. Another open source solution, OpenBehavior, has many of the same aims as our system but appears to only support fixed-ratio reinforcement and is still in early development [@OpenBeh]. The most flexible operant conditioning system for birds is ARTSy, but this requires an expensive National Instruments I/O card, Windows OS, and Matlab, and the necessary Matlab code does not appear to be currently openly available [@Gess2011].

Given these considerations, Prof. Clayton and I decided to work with Dr. Lachlan to implement a new open source hardware/software system that would immediately support the aims of my research but would also be readily adaptable for other purposes. Dr. Lachlan had already begun to develop Java-based software for operant conditioning based on an Arduino computer. My role was to work with him and Dr. Julia George to design and build the necessary Raspberry Pi-based hardware including the electronics and enclosures for the electronics, and to refine and extend the software. In the rest of this chapter, I provide a detailed description of the resulting system, "Operanter".

##What is Operanter
Operanter is a flexible and intuitive operant conditioning system. Originally built for a specific Go/No-Go auditory task with zebra finches, Operanter was designed to be easily extendable for all operant conditioning paradigms, including ABX/AXB and two-alternative forced choice tasks. It was also designed to facilitate inexpensive operant conditioning setups based on a Raspberry Pi computer module and customisable hardware. To this end, the Operanter software was written in Java but will require only simple XML files to edit the training schemes. Instructions on how to install Operanter and build an operant conditioning setup are provided on the Operanter GitHub Wiki pages (https://github.com/rflachlan/Operanter/wiki). The Operanter software controls multiple peripheral components usng a Raspberry Pi running Raspbian.

###Hardware: Raspberry Pi
Operanter was developed on a Raspberry Pi B+ running Raspbian Jessie (\autoref{fig-operanterpics}). It has been tested only on Raspbian Jessie 4.1 but should work on earlier versions, albeit without touchscreen support. The Operanter software is designed to be as lightweight as possible and currently requires less than 8MB for both installation and for activity log saving. The Operanter software uses less than 5% CPU of the Raspberry Pi B+, which allows for multiple other processes to run in parallel on the Raspberry Pi unit, such as sound or video recording/monitoring.

###Hardware: Peripheral components
The Operanter software is designed to work with the do-it-yourself (DIY) hardware on our GitHub Wiki. I describe how to use inexpensive and manufacturer-independent parts to build three types of components: 

The Operanter software interacts with the peripheral components via a Java class for each component. The exact control of the components can be modified with basic programming, but the creation of new classes for new component designs might require some knowledge of Java. However, with the inclusion of radio-controlled on/off outlets in our preliminary design, any component that can be turned on or off by an outlet can be controlled by Operanter without modification to the source code.

```{r echo=FALSE, fig.cap="\\label{fig-operanterpics}Operanter hardware, Raspberry Pi and electronics. A) The chamber with individual Raspberry Pi on top. B) Back of Raspberry Pi with GPIO connections to peripheral components. C) Infrared sensors and food hatch inside the cage."}

include_graphics('./External_images/operanterpics.pdf')
```

Though with adequate programming, any peripheral components can be built and controlled with Operanter, I developed the following three tpes of components: solid-state relay-controlled lights, infrared sensors/LED devices for the interactive component, and a linear servo motor to power the food hatch covers for controlling access to food. These components are connected to the Raspberry Pi by ethernet cables, which help to minimise the number of cables necessary to control each chamber.

####Light component
Automated control of light in the chamber is required for both the daily light/dark schedule, and control of punishment in our operant conditioning procedure. I considered two approaches to control the light: a remote/radio solution from Energenie, and a solid-state relay. I initially developed a system based on the Energenie Pi-mote (https://energenie4u.co.uk/), a radio-controlled on/off outlet that integrates with a Raspberry Pi. This control system simply involved wiring a light to a standard 13A UK mains plug, which was then plugged into the Energenie socket. Energenie supplies an add-on for the Raspberry Pi, which sends radio signals via the Raspberry Pi's GPIO pins, effectively turning the Raspberry Pi into a remote. Using sample code supplied by Energenie, Operanter controlled the light with sufficiently short lag times to enable a bird to learn the Go/No-Go procedure (data not shown). However, when eight chambers were placed in the same room, the radio signals were not sufficiently differentiated, and the radio signals from one Raspberry Pi/Energenie unit interfered with the signals from another unit. I estimated that a maximum of four chambers can be used in the same location without this issue arising. Therefore, for small laboratories where there will not be many chambers in use at the same time, the Energenie-based control method may be useful for controlling peripheral components without a direct/wired link to the Raspberry Pi.

However, the project for which Operanter was developed required eight chambers to run in tandem. I therefore developed a simpler wired control system based on a solid-state relay device. The advantage of the solid-state relay is its precise control of the electrical component to which it is wired, with no risk of radio interference between chambers. In contrast to the Energenie remote approach, developing the solid-state relay requires more confidence with electrical wiring as it involves directly wiring a 13A UK mains plug to the solid-state relay device: the power source is much greater than the few hundred milliamps used for the remainder of the electrical components used by Operanter. Additionally, the correct solid-state relay must be purchased: the default state of the relay can be on or off, and if the Raspberry Pi fails, the solid-state relay will default to either open or closed. I therefore selected a default-on solid-state relay so that birds would not be in darkness in the case of software/hardware failure. I selected the solid-state relay as the final control unit for the light in the operant conditioning setup as it had none of the radio interference issues, and was also faster at switching the chamber light on and off (McMahon, pers. obs.).

####Interactive sensors/LED component
In order for an organism to be automatically operantly conditioned, the apparatus requires a sensor component that allows the bird to indicate its choice (Go or No-Go). Additionally, previous researchers who have trained birds using operant conditioning have found success using lights to indicate when sensors are active (e.g. ten Cate laboratory at Leiden University). I therefore aimed to replicate this approach by integrating an LED light behind a sensor. All sensors described were wired to GPIO ports on the Raspberry Pi via an Ethernet connection.

I first replicated the button/switch type of sensor used at the ten Cate laboratory at Leiden University, but this form of sensor was unreliable due to the mechanical movement of the sensor itself. I then developed a highly sensitive vibration-based sensor (SW-18010P), which requires only 1g of force to trigger. This sensor responded when the bird pecked, but was also unreliable as it was occasionally triggered by a bird's excessive hopping around the chamber. To resolve this, I finally developed an infrared detection-based sensor (\autoref{fig-sensorcomponent}). This sensor (GP1A57HRJ00F) is a U-shape with an infrared emitter at one end and an infrared detector opposite at the other end. When the beam from the emitter end is interrupted by a bird's beak, the detector recognises that it is no longer receiving the the infrared beam and sends a signal to the Raspberry Pi. The infrared sensor has no moving parts so is not susceptible to jamming like the button sensor, and cannot be accidentally triggered by hopping movement like the vibration sensor.

```{r echo=FALSE, fig.cap="\\label{fig-sensorcomponent}The sensor and LED component. The bird's beak breaks the infrared beam from the emitter to the detector ends of the infrared sensor, and an LED component indicates when the sensor is active and provides an illuminated target for the bird's beak."}

include_graphics('./External_images/sensor_component.pdf')
```

In order to indicate to the bird whether or not the sensor is active, and to provide a target for the bird's beak to peck, an LED needs to be placed in between the emitter and detector arms of the infrared sensor (\autoref{fig-sensorcomponent}). To match the sensor setup at the ten Cate laboratory at Leiden University, I first integrated a red LED into the sensor component. Researchers at Leiden University suggested that the red LED was originally selected because they believed it would attract the attention of zebra finches due to the attractiveness of red beaks [@Simons2011]. Unfortunately, with the red LED in position, the beam from the infrared emitter to the infrared detector could not be broken. This was because the red LED emitted light at wavelength 623 nm, which is between the range detected by the infrared detector (400-1200 nm with maximum sensitivity at 900 nm); that is, the infrared detectors are not just infrared detectors, but they detect wavelengths from violet to infrared. With the red light from the LED exciting the infrared detector, a bird could repeatedly peck at the sensor and not trigger the detector.

A green LED (525 nm) was used to replace the red LED, which attenuated the problem. However, even 525 nm excited the "infrared" detector when the green was bright enough. To resolve this problem, black nail varnish was painted around the sides of the LED cylinder so that the LED could only project light from the end. Black nail varnish was also painted around the inside of the sensor enclosure to reduce the reflectivity and the effect of leaking light from the LED. This reduced the intensity of the green light sufficiently so that a bird's beak could break the infrared sensor's beam, and the detector would not be excited by the LED light. Though no quantitative analysis was conducted on the attractiveness of red versus green LEDs, birds were easily and quickly able to learn to peck at the green LED. Future developers may wish to consider the use of blue LEDs (470 nm) to further ammeliorate the problem of residual light from the LED triggering the detector.

####Food hatch motor component
Just as the light component controls the operant conditioning punishment, the food hatch motor component controls the operant conditioning reward: access to seed. Other implementations of avian operant conditioning software use a variety of methods to control access to seed. The ten Cate laboratory at the University of Leiden uses a linear servo motor that raises a vertical opaque window. The bird then pokes its head through the gap to access seed that is stored outside the cage [e.g. @Heijningen2009]. The ARTSy system developed at the Woolley laboratory at Columbia University uses a solenoid motor that drives a food hopper from outside the chamber to inside the chamber where the bird can access the food [@Gess2011]. The vertical window system risks the window falling on the bird's neck if the mechanism jams, and the laboratory's pre-built sound isolation chambers did not have enough space to move an entire food hopper in and out of the cage. To optimise the space for birds to move about the cage and to reduce the risk of injury, a linear servo motor was designed that moves a horizontal food hatch cover.

###Software
Operanter is written in the Java language; the Java Runtime Environment included in the Raspbian Jessie operating system distribution is sufficient to run Operanter. Operanter also uses the H2 database engine to record and analyse activity and the Pi4J library to communicate with the Raspberry Pi. These are included in the Operanter file and do not require separate installation. Operanter is distributed as a .jar file that runs by double clicking with administrative permissions and does not need installation. It can be downloaded from the Operanter GitHub website. The Operanter graphical user interface (GUI) comprises a single window with five tabs: Schedule, Operant Experiment, Log, Direct Control, and Stats (\autoref{fig-operanterpics2}). The entire GUI is optimised for touch-screen interaction; all regularly used buttons are large to enable quick and accurate interaction with the software.

```{r echo=FALSE, fig.cap="\\label{fig-operanterpics2}Operanter software. A) Schedule tab. B) Operant Experiment tab. C) Log tab. D) Stats tab."}

include_graphics('./External_images/operanterpics2.pdf')
```

The Schedule tab allows the user to set a daily schedule for when the lights are on and when the experiment runs. From this tab, the lights can be manually turned on an off, and the experiment can be manually stopped and started. This panel can be used to set a safety mechanism (maximum duration that the food hatch can remain closed); this feature allows our laboratory to comply with Home Office requests to implement technical solutions to reduce the risk of animals not feeding due to inactivity. From the Schedule tab, users can also set the computer system time, and to set the times, that Operanter automatically exports data. 

The Operant Experiment tab is where new schemes are created and saved. It provides an interface for setting some of the frequently modified defaults for the peripheral components. For example, the duration of the rewarder can be set here, but the rules that trigger the rewarder remain controlled by the programmed scheme and cannot be modified using the GUI. Similarly, if a pre-programmed scheme uses a sound output channel, the Operant Experiment tab will allow the user to switch between available channels.

The Log tab shows a table of all activity. It displays the time of day, the activity (e.g. Switch On, Reward), the component that completed the activity (e.g. LED1, Rewarder) and the scheme name. The Log tab contains a button that forces Operanter to save the log file on demand, either as a comma-separated value or Excel file. Data can also be deleted from this table. 

The Direct Control tab is where the user can force peripheral component activity, which is especially useful during hand-shaping. All components referenced in the current scheme will appear in the Direct Control tab. For example, the LEDs can be flashed and the food hatch can be opened and closed on demand. Large buttons on this panel enable the researcher or technician to view the bird's behaviour on half of the touch-screen and manually control the chamber with the other half.

Finally, the Stats panel shows a summary of how many times each action has been performed by each peripheral component, allowing researchers and animal caretakers to quickly determine the level of an animal's activity and success. It requires a user-input time, which enables the user to view activity from a certain time, such as yesterday morning or from the beginning of the week; the time defaults to the most recent start-up time of the software or scheme. 

Changes to the operant experiment design must be made at multiple levels. The GUI Operant Experiment tab is useful for changing a few simple settings for the peripheral components, but changes to the relationship between peripheral components must currently be made by editing a scheme in the Java code. I plan to extend the software so schemes can be added by importing syntactically simple XML files with the logic for the new scheme. Only two schemes (Go/No-Go and a preliminary shaping phase) are currently available, but I plan to add schemes for ABX, AXB, 2-alternative forced choice, and preference test designs. Finally, for any users who need to make significant changes to Operanter, such as adding a new peripheral component, the source code is available on the Operanter Github website.

###Ease of use
Operanter has been designed to be as easy to use and as intuitive as possible. The GUI comprises five tabs with straightforward functionality. Instructions on the GitHub Wiki assume little knowledge of Raspberry Pi programming and electronics, and will soon be updated to be more thorough.

Operanter is available through a GitHub repository; both the executable .jar file containing software and the source code can be downloaded. Operanter will continue to be updated with new bug fixes whenever they are discovered. The Wiki on the GitHub repository can be edited by users who would like to contribute documentation. The source code can be forked and modified by anyone who would like to extend the code.

##Conclusion
Operanter is free open source software and hardware for controlling operant conditioning that runs on a Raspberry Pi computer. Originally designed for avian auditory Go/No-Go training, Operanter supports other forms of operant conditioning such as ABX and two-alternative forced choice designs, and can be used to run sound playback experiments. It controls day/night light cycles, reward/punishment procedures, and backup safety mechanisms. It also supports direct control of the operant conditioning hardware for auto- and hand-shaping training stages. Operanter provides summarised information about the training activity to enable animal care staff and researchers to easily determine an animal’s progress. Daily logs are automatically exported to a .csv file for later processing. A single setup with a dedicated computer, touchscreen display and reward/punishment hardware can cost as little as £250. The affordability and flexibility of Operanter systems allows researchers with small budgets or specific needs to carry out operant conditioning experiments. In the next chapter (Chapter 4), I will describe an experiment validating the efficacy of the Operanter system.

